# SPRING ADVANCED

## Lv 3. 추가 기능 개선

### **1. 코드 개선 퀴즈 -** Early Return

- 조건에 맞지 않는 경우 즉시 리턴하여, 불필요한 로직의 실행을 방지하고 성능을 향상시킵니다.
    - 패키지 `package org.example.expert.domain.auth.service;` 의 `AuthService` 클래스에 있는 `signup()` 중 아래의 코드 부분의 위치를 리팩토링해서
    - 해당 에러가 발생하는 상황일 때, `passwordEncoder`의 `encode()` 동작이 불필요하게 일어나지 않게 코드를 개선해주세요.

### **2. 리팩토링 퀴즈 - 불필요한 `if-else` 피하기**

복잡한 `if-else` 구조는 코드의 가독성을 떨어뜨리고 유지보수를 어렵게 만듭니다.
불필요한 `else` 블록을 없애 코드를 간결하게 합니다.

### **3. 코드 클린업 : 불필요한 주석 제거, 코드 포맷팅, 일관된 네이밍 컨벤션 적용**

- 불필요한 주석 제거
    - 코드가 명확하게 이해될 수 있도록 불필요한 주석은 제거합니다.
        - 주석의 추상화 수준과 코드의 추상화 수준의 동일한 경우
        - 주석이 코드의 내용을 중복하는 경우 제거
        - 설명이 불명확하거나 혼란스러운 주석 삭제
        - 코드의 동작을 설명하기보다는 '왜' 해당 코드를 작성했는지를 설명하는 주석은 남김
- 코드 포맷팅
    - 일관된 코드 스타일을 유지하기 위해 코드 포맷팅을 적용합니다.
        - 각 클래스, 메서드, 변수에 대한 적절한 공백 및 줄바꿈 적용
        - 2칸 또는 4칸의 스페이스(탭) 사용, 팀 내 합의된 방식에 따름
        - 괄호 `{}`는 다음 줄에 위치시키거나 같은 줄에 위치시키는 규칙을 팀 내에서 정하고 적용
        - 한 줄의 최대 길이는 80~120자로 제한
        - 메서드 인자와 파라미터 목록 간의 공백 적용
        - 코드 정렬 및 정리(예: import 문 정리)
        - `Hint!` google-java-formatter, ktlint 와 같은 린트도 찾아서 활용해보세요!
- 일관된 네이밍 컨벤션 적용
    - 변수명, 메서드명, 클래스명 등 모든 네이밍에 대해 일관된 규칙을 적용합니다.
        - 클래스 이름은 대문자로 시작하는 파스칼 케이스(`PascalCase`) 사용
        - 메서드 이름 및 변수 이름은 소문자로 시작하는 카멜 케이스(`camelCase`) 사용
        - 상수 이름은 모두 대문자로 작성하고 단어 사이에 언더스코어(`_`) 사용 (예: `MAX_LENGTH`)
        - 이름이 그 행위를 충분히 설명하고 있는지?
          네이밍은 의미를 명확히 전달하도록 작성 (예: `getUserById`는 `findUserById`로 변경 가능)
        - 접두사 또는 접미사를 통한 일관성 유지 (예: DTO는 `UserDTO`, Service는 `UserService` 등)

  **주의사항!**
  코드 포맷팅의 경우, 팀 내 합의된 방식에 따름’에 주목!
    - 반드시 제시된 조건에 따라 진행할 필요는 없습니다.
    - 추후 프로젝트 진행을 위해, 팀 내에서 규칙을 정할 수 있도록 미리 연습하는 것!
    - 개인 과제 특성상, 본인이 지정할 때 “왜?” 그렇게 지정하려고 했는지 생각해보세요!

### **4. 중복 코드 제거 : 반복적으로 사용되는 코드의 재사용성 향상**

- 중복 코드 식별
    - 프로젝트 내에서 반복적으로 사용되는 코드를 찾아냅니다.
        - 유사한 로직이 여러 곳에서 사용되는지 확인
        - 동일한 기능을 수행하는 코드 블록을 검색
        - 메서드 내의 반복적인 코드나 클래스 간의 중복 코드 파악
- 메서드로 추출
    - 중복된 코드를 유틸리티 메서드로 추출하여 재사용성을 높입니다.
        - 중복 코드의 기능을 분석하고, 재사용 가능한 메서드를 생성
        - 메서드 이름은 기능을 명확히 전달할 수 있도록 작성
        - 메서드는 단일 책임 원칙(SRP)을 준수해야 하며, 한 가지 기능만 수행하도록 구현

  **주의사항!**
    - 단순 private 메소드로의 추출을 말하는 것이 아닙니다.
        - private 메소드를 먼저 떠올린다면 구조적인 고민할 기회가 없어져요!
    - 해당 코드를 더 잘 수행할 것 같은 객체에게 “위임”하거나,
    - 객체를 만들어 메소드를 분리해야합니다.

- 단순 private 메소드로의 추출을 기대하는게 아니라고 강조되었으면 좋겠습니다. 해당 코드를 더 잘 수행할 것 같은 객체에게 위임하거나 객체를 만들어서 메소드를 분리해야하는데, private 메소드를 먼저
  떠올리면 구조적인 고민을 할 기회가 없어지기 때문입니다.

## Lv 4. N+1 문제 개선하기

- `TodoController`와 `TodoService`를 통해 `Todo` 관련 데이터를 처리합니다. (github 코드 기준)
- 여기서 N+1 문제가 발생할 수 있는 시나리오는 `getTodos` 메서드에서 모든 Todo를 조회할 때, 각 Todo와 연관된 데이터를 개별적으로 가져오는 경우입니다.
- 이를 해결하기 위해 `fetch join`과 `EntityGraph`를 활용할 수 있습니다.
- 요구사항:
    - `fetch join`을 사용한 N+1 문제 해결
        - `TodoRepository`에서 JPQL을 작성하여 `fetch join`을 사용합니다.
    - `@EntityGraph`를 사용한 N+1 문제 해결
        - Spring Data JPA에서 `@EntityGraph`를 활용하면 `fetch join`을 선언적으로 사용할 수 있습니다.
- 선택 기준 (고민해보시고, 적용해주세요!)
    - **`fetch join`**
        - 복잡한 쿼리에서 더 유연하게 동작.
        - 필요에 따라 추가 조건을 명시할 수 있음.
    - **`@EntityGraph`**
        - 선언적으로 간단하게 N+1 문제를 해결할 수 있음.
        - 간단한 연관 관계에서 유리.

-  ## Lv 5. 테스트코드 & API 로깅

### **1. 테스트 연습 1 (예상대로 성공하는지에 대한 케이스입니다.)**

- 테스트 패키지 `package org.example.expert.config;` 의 `PassEncoderTest` 클래스에 있는 `matches_메서드가_정상적으로_동작한다()` 테스트가 의도대로 성공할 수
  있게
  수정해 주세요.

### **2. 테스트 연습 2 (예상대로 예외처리 하는지에 대한 케이스입니다.)**

- 1번 케이스
    - 테스트 패키지 `package org.example.expert.domain.manager.service;` 의 `ManagerServiceTest` 의 클래스에 있는
      `manager_목록_조회_시_Todo가_없다면_NPE_에러를_던진다()` 테스트가 성공하고 컨텍스트와 일치하도록 **테스트 코드**와 **테스트 코드 메서드 명**을 수정해 주세요.

- 2번 케이스
    - 테스트 패키지 `org.example.expert.domain.comment.service;` 의 `CommentServiceTest` 의 클래스에 있는
      `comment_등록_중_할일을_찾지_못해_에러가_발생한다()` 테스트가 성공할 수 있도록 **테스트 코드**를 수정해 주세요.

- 3번 케이스
    - 테스트 패키지 `org.example.expert.domain.manager.service`의 `ManagerServiceTest` 클래스에 있는
      `todo의_user가_null인_경우_예외가_발생한다()`
      테스트가 성공할 수 있도록 **서비스 로직**을 수정해 주세요.

### **3. Interceptor와 AOP를 활용한 API 로깅**

- **키워드 : Interceptor 또는 AOP를 활용합니다.**
- 어드민 사용자만 접근할 수 있는 특정 API에는 접근할 때마다 접근 로그를 기록해야 합니다.

**요구사항:**

1. 어드민 사용자만 접근할 수 있는 컨트롤러 메서드는 다음 두 가지예요.
    - `org.example.expert.domain.comment.controller.CommentAdminController` 클래스의 `deleteComment()`
    - `org.example.expert.domain.user.controller.UserAdminController` 클래스의 `changeUserRole()`

**로깅 구현 방법:**

1. **Interceptor**를 사용하여 구현하기
    - 요청 정보(`HttpServletRequest`)를 사전 처리합니다.
    - 어드민 권한 여부를 확인하여 인증되지 않은 사용자의 접근을 차단합니다.
    - 인증 성공 시, 요청 시각과 URL을 로깅하도록 구현하세요.
2. **AOP**를 사용하여 구현하기
    - 어드민 API 메서드 실행 전후에 요청/응답 데이터를 로깅합니다.
    - 로깅 내용에는 다음이 포함되어야 합니다:
        - 요청한 사용자의 ID
        - API 요청 시각
        - API 요청 URL
        - 요청 본문(`RequestBody`)
        - 응답 본문(`ResponseBody`)
3. **세부 구현 가이드**
    - **Interceptor**:
        - Spring의 `HandlerInterceptorAdapter`를 상속받아 구현합니다.
        - `preHandle()`에서 어드민 인증 여부를 확인합니다.
        - 인증되지 않은 경우 예외를 발생시킵니다.
    - **AOP**:
        - `@Around` 어노테이션을 사용하여 어드민 API 메서드 실행 전후에 요청/응답 데이터를 로깅합니다.
        - 요청 본문과 응답 본문은 JSON 형식으로 기록하세요.
    - 로깅은 `Logger` 클래스를 활용하여 기록합니다.

**힌트:**

1. Interceptor:
    - 사용자의 인증 정보는 `SecurityContextHolder` 또는 `HttpServletRequest`에서 가져올 수 있습니다.
    - `preHandle()`에서 URL, 헤더 등의 정보를 가져옵니다.
2. AOP:
    - 요청 본문은 `@RequestBody`로 전달된 객체를, 응답 본문은 반환된 객체를 확인합니다.
    - 요청과 응답 데이터를 읽기 위해 `ObjectMapper`를 활용하세요.
3. 요청 본문과 응답 본문을 로깅하기 위해 ContentCachingRequestWrapper, ContentCachingResponseWrapper활용할 수 있습니다.